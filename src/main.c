/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  tbf_rx65n_gcc                          */
/*      FILE         :  tbf_rx65n_gcc.c                        */
/*      DESCRIPTION  :  Main Program                           */
/*                                                             */
/*      This file was generated by e2 studio.                  */
/*                                                             */
/***************************************************************/
// #include <stdio.h>
#include <string.h>

#include <intprg.h>

#include "common.h"
#include "sci8.h"
#include "gpio.h"
#include "cmt.h"
#include "adc.h"

void split_16_8(uint16_t num, uint8_t *ary);
uint8_t split_16_ascii(uint16_t num, uint8_t *ary);


uint8_t str[] = "Hello! from RX65N\r\n";
uint8_t return_key[] = "\r\n";



int main(void)
{
	// uint8_t timer_status;
	uint16_t sendNum;
	uint8_t adcStr[0x10] = {0};
	uint16_t voltage;

	// uint16_t num;

	selective_interrupt_create();
	group_interrupt_create();

	gpio_create();
	cmt_create();
	sci8_create();
	adc_create();

	sci8_start();
	cmt2_start();


	led_ctrl(LED0, LED_ON);
	led_ctrl(LED1, LED_OFF);

	while(1) {
		voltage = convert_16_voltage(S12AD.ADDR0);	// 電圧取得
		sendNum = split_16_ascii(voltage, adcStr);	//
		adcStr[sendNum] = ' ';	sendNum++;
		adcStr[sendNum] = 'm';	sendNum++;
		adcStr[sendNum] = 'V';	sendNum++;
		adcStr[sendNum] = '\r';	sendNum++;
		adcStr[sendNum] = '\n';	sendNum++;
		sci8_send(adcStr, sendNum);
		while (0 == sci8_send_end);		// 送信完了待ち
		// sci8_send(return_key, (uint16_t)sizeof(return_key) - 1);
		// while (0 == sci8_send_end);		// 送信完了待ち

		cmt_wait(0, MILLI_SEC, 1000);

		led_toggle(LED0);
		// led_toggle(LED1);

		// cmtw0_start(MILLI_SEC, 500, &timer_status);
		// while (!timer_status);
		// led_toggle(LED0);
		// led_toggle(LED1);
		// cmtw1_start(MILLI_SEC, 500, &timer_status);
		// while (!timer_status);
		// led_toggle(LED0);
		// led_toggle(LED1);
		// cmtw0_start(MICRO_SEC, 50000, &timer_status);
		// while (!timer_status);
		// led_toggle(LED0);
		// led_toggle(LED1);
		// cmtw1_start(MICRO_SEC, 50000, &timer_status);
		// while (!timer_status);
	}

	return 0;
}


//! 100ms経過ごとに呼ばれる
void INT_Excep_PERIB_INTB128(void)
{
	// sci8_send(str, (uint16_t)sizeof(str) - 1);
	// led_toggle(LED0);
	// led_toggle(LED1);

}


//! 符号なし16ビットを符号なし8ビットの配列に代入
void split_16_8(uint16_t num, uint8_t *ary)
{
	uint16_t tmp_lo = num & 0x00FF;
	uint16_t tmp_hi = num & 0xFF00;

#if (RX65N_BYTE_ORDER == RX65N_LITTLE_ENDIAN)
	ary[1] = (uint8_t)tmp_lo;
	ary[0] = (uint8_t)(tmp_hi >> 8);
#else
	ary[0] = (uint8_t)tmp_lo;
	ary[1] = (uint8_t)(tmp_hi >> 8);
#endif
}

//! 符号なし16ビットを文字列に代入
uint8_t split_16_ascii(uint16_t num, uint8_t *ary)
{
	uint8_t digit = 0;	// 10進法の桁数
	uint16_t tmp;
	uint8_t i;	//

	// numの桁数を計算
	tmp = num;
	while (1) {
		digit++;
		if (tmp >= 10)	tmp /= 10;	// 10以上なら1桁ぶん右シフト
		else			break;
	}

	// asciiに変換して配列に代入
	tmp = num;
	for (i = 0; i < digit; i++) {
		ary[digit - i - 1] = (uint8_t)((tmp % 10) + '0');
		tmp /= 10;
	}

	return digit;
}

